@import url('https://fonts.googleapis.com/css?family=Open+Sans:300,400,700');

html {
  height: 100%;
}

/* Lets make the 'drawing canvas' some big block which is relatively positioned. */
#drawingCanvas {
    position: relative;
    height : 500px;
    width  : 500px;
    background-color : bisque;
    /*transform: scale(1); TODO -- figure out a way to scale everything together without breaking everything */
}

/* Style the 'context box indicator' (thing which sits in the corner and tells you what the current context is */
#contextIndicatorBox {
    position: absolute;
    top: 0px;   /* Sit in the top left corner */
    left: 0px;
    z-index: 1;     /* don't let this render on top of nodes */

    height: 22px;
    width:  200px;

    background-color: darkblue;

    border-radius: 3px;
    border-width: 3px;
    border-style: solid;
    border-color: grey;
}

#contextIndicatorBox span {
    color: cornsilk;
    text-align: center;
}

/* Style the button inside the context box indicator */
#contextIndicatorBox button:hover {
    cursor: pointer;
}

/* Style the svg object to be overlaid with the drawing canvas */
#svgObject {
    position: absolute;
    top: 0px;
    left: 0px;
    background-color: transparent;
    z-index: 0;
}

/* Style the svg LINES that are inside the svgObject */
#svgObject line {
    stroke:rgb(255,0,0);
    stroke-width:2
}

/* Style the 'drag here to delete' box */
.utilityDropZone {
    display: inline-block;  /* relavtively positioned inline block */
    position: relative;     /* move them relative to the canvas, but not absolute, so they still tile themselves amongst each other */
    transform-origin: bottom left;
    transform: translate(0px, 446px); /* Sit in the bottom left corner, by translating distance downwards*/

    z-index: 1;     /* don't let this render on top of nodes */

    height: 50px;
    width:  100px;

    background-color: #ad9d7f;

    border-radius: 3px;
    border-width: 2px;
    border-style: solid;
    border-color: grey;

    text-align: center;

    /* Future CHANGES to the border should have a graceful transition time */
    transition-property: border-width, border-color, border-style;
    transition-duration: 0.25s;
}

/*  --------------------- NODE RELATED STYLING ---------------------------------------------------------------------- */

/* Lets make any 'node' element be absolutely positioned on y of it's parent */
/* This is so that it can be positioned anywhere on the parent               */
/* The styling on this element will serve as the 'base' styling of all nodes. When 'actions' happen to nodes
   (I.e. the user creates events through their interactions) then, nodes will visually respond to these changes.)
   To define these changes, we can use CSS rules which apply to class types corresponding to each 'event state'.
   Then, we will PROGRAMMATICALLY assign the relevent nodes to be of that class. CSS will apply those rules and
   overwrite any properties from this base rule. Then, when the action/event ends, we can simply remove the class
   from the class list of the relevent elements, which will return the rendering to this base rule */
.node {
    /* Positioning rules. Should probably not be overwritten ever, as doing so would mess up all positioning calculations */
    position : absolute;
    top : 0px;
    left : 0px;

    transform-origin: center;

    /* Nodes look nicer with rounded corners! */
    border-radius: 5px;

    /* Nodes should have a nice looking border */
    border-width: 3px;
    border-color: black;
    border-style: solid;

    /* Future CHANGES to the border should have a graceful transition time */
    transition-property: border-width, border-color, border-style;
    transition-duration: 0.25s;

    /* Nodes should have their title text CENTRED */
    /* TODO -- make it so that collapsed, small nodes centre their title text, but larger ones have it up the top */
    text-align: center;
}

/* Let's implement a default colouring and shit for content nodes, for testing purposes */
.contentNode {
    color : cornsilk;   /* test colour for the nodes name at this time */
}


/* Style the expand/collapse icon */
.expandChildrenButton {
    position: relative;
    transform: translate(6px, 15px);

    background: url("../images/expand-button.svg") no-repeat;
    background-size: cover;
    rotation-point:50% 50%;
    width: 15px;
    height: 15px;
    transition: transform 0.25s;
}
.expandChildrenButton:hover {
    cursor : pointer;
}
.expandChildrenButton_expanded {
    transform : translate(6px, 15px) rotate(0deg);
}
.expandChildrenButton_collapsed {
    transform: translate(6px, 15px) rotate(-90deg);
}



/* ------------------------------------------------------------------------------------------------------------------ */
/* --- DYNAMICALLY APPLIED STYLES ----------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------ */
/* These are rules that will be applied to classes which will be dynamically be added and removed based on user       */
/* actions. Mostly, these will provide visual feedback as to things which have just happened, and possible actions!   */
/* ------------------------------------------------------------------------------------------------------------------ */

/* Define custom style for nodes which are potential 'droppable' areas */
.potentialDropzone {
    /* potential drop zones will all have dashed borders, which turn dark red (arbitrarily chosen) */
    border-style: dashed;
    border-color: darkred;
}
.potentialUtilityDropzone {
    border-style: dashed;
    border-color: darkblue;
}

/* Define custom style for drop zone nodes, which have just had an element dragged into them.
   I.e. the user is 'hovering' a droppable node over the drop zone, but has not let go of the mouse button yet */
.potentialDropzoneHasItemHovering {
    border-width : 5px;
}
.potentialUtilityDropzoneHasItemHovering {
    border-width : 5px;
}






